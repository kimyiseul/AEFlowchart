// Connect (ctrl shift c)

#import 'AEFlowchart.js'

/*  call AEFlowchart main function with custom name and lineShape function  */
connectSteps(drawAllConnections);

function drawAllConnections(selection)
{

  // sort selection from top to bottom steps
  var sortedSelection = [];
  var loop = [selection objectEnumerator];
  while (item = [loop nextObject]) {
    sortedSelection.push(item);
  }
  sortedSelection = sortedSelection.sort(sortByPosition);

  // draw connection between every two steps
  for (var i = 0; i < sortedSelection.length; i++) {
    // skip last step (there is no step after to connect)
    if ((i + 1) < sortedSelection.length) {
      drawOneConnection(sortedSelection[i], sortedSelection[i + 1]);
    }
  }
}

function drawOneConnection(firstStep, secondStep) 
{
  // get connectionsGroup position
  var parentGroup = [firstStep parentGroup];
  var connectionsGroup = getConnectionsGroup(parentGroup);
  var connectionsGroupFrame = [connectionsGroup frame];
  var connectionsGroupX = [connectionsGroupFrame x];
  var connectionsGroupY = [connectionsGroupFrame y];

  // get frames of steps
  var firstStepFrame = [firstStep frame];
  var secondStepFrame = [secondStep frame];

  // get First point
  var firstStepBottom,
      firstStepRight,
      firstStepHorizontalMiddle, 
      firstStepVerticalMiddle;

  if (firstStep.name().indexOf("Decision -") > -1) {

    var decisionShape = firstStep.layers().array()[0];
    var decisionShapeFrame = decisionShape.frame();

    log ("First " + decisionShape.name())

    firstStepBottom = firstStepFrame.minY() + decisionShapeFrame.maxY() - connectionsGroupY;
    firstStepRight = firstStepFrame.minX() + decisionShapeFrame.maxX() - connectionsGroupX;
    firstStepHorizontalMiddle = firstStepFrame.minX() + decisionShapeFrame.midX() - connectionsGroupX;
    firstStepVerticalMiddle = firstStepFrame.minY() + decisionShapeFrame.midY() - connectionsGroupY;

    log (firstStepBottom);
    log (firstStepRight);
    log (firstStepHorizontalMiddle);
    log (firstStepVerticalMiddle);

  } else {
    firstStepBottom = firstStepFrame.maxY() - connectionsGroupY;
    firstStepRight = firstStepFrame.maxX() - connectionsGroupX;
    firstStepHorizontalMiddle = firstStepFrame.midX() - connectionsGroupX;
    firstStepVerticalMiddle = firstStepFrame.midY() - connectionsGroupY;
  }

  // get Second point
  var secondStepTop,
      secondStepLeft,
      secondStepHorizontalMiddle, 
      secondStepVerticalMiddle;

  if (secondStep.name().indexOf("Decision -") > -1) {
    var decisionShape = secondStep.layers().array()[0];
    var decisionShapeFrame = decisionShape.frame();

    log ("Second " + decisionShape.name())

    secondStepTop = secondStepFrame.minY() + decisionShapeFrame.minY() - connectionsGroupY;
    secondStepLeft = secondStepFrame.minX() + decisionShapeFrame.minX() - connectionsGroupX;
    secondStepHorizontalMiddle = secondStepFrame.minX() + decisionShapeFrame.midX() - connectionsGroupX;
    secondStepVerticalMiddle = secondStepFrame.minY() + decisionShapeFrame.midY() - connectionsGroupY;
  } else {
    secondStepTop = secondStepFrame.minY() - connectionsGroupY;
    secondStepLeft = secondStepFrame.minX() - connectionsGroupX;
    secondStepHorizontalMiddle = secondStepFrame.midX() - connectionsGroupX;
    secondStepVerticalMiddle = secondStepFrame.midY() - connectionsGroupY;
  }

  // calcurate the half point
  var horizontalSpacingHalf = (secondStepLeft - firstStepRight) / 2;
  var verticalSpacingHalf = (secondStepTop - firstStepBottom) / 2;
  var horizontalMiddleDifference = firstStepHorizontalMiddle - secondStepHorizontalMiddle;
  var verticalMiddleDifference = firstStepVerticalMiddle - secondStepVerticalMiddle;

  log ("horizontalMiddleDifference " + horizontalMiddleDifference);
  log ("verticalMiddleDifference " + verticalMiddleDifference);  

  // create NSBezierPath
  var lineBezierPath = [NSBezierPath bezierPath];

  if (firstStepBottom < secondStepTop) {
    // draw vertical connection
    [lineBezierPath moveToPoint:CGPointMake(firstStepHorizontalMiddle, firstStepBottom)];
    // tolerate some pixels in horizontalMiddleDifference
    if (Math.abs(horizontalMiddleDifference) > 2.0) {
      [lineBezierPath lineToPoint:CGPointMake(firstStepHorizontalMiddle, firstStepBottom + verticalSpacingHalf)];
      [lineBezierPath lineToPoint:CGPointMake(secondStepHorizontalMiddle, firstStepBottom + verticalSpacingHalf)];
      [lineBezierPath lineToPoint:CGPointMake(secondStepHorizontalMiddle, secondStepTop)];
    } else {
      [lineBezierPath lineToPoint:CGPointMake(firstStepHorizontalMiddle, secondStepTop)];
    }
  } else {
    // draw horizontal connection
    [lineBezierPath moveToPoint:CGPointMake(firstStepRight, firstStepVerticalMiddle)];
    // tolerate some pixels in verticalMiddleDifference
    if (Math.abs(verticalMiddleDifference) > 2.0) {
      [lineBezierPath lineToPoint:CGPointMake(firstStepRight + horizontalSpacingHalf, firstStepVerticalMiddle)];
      [lineBezierPath lineToPoint:CGPointMake(firstStepRight + horizontalSpacingHalf, secondStepVerticalMiddle)];
      [lineBezierPath lineToPoint:CGPointMake(secondStepLeft, secondStepVerticalMiddle)];
    } else {
      [lineBezierPath lineToPoint:CGPointMake(secondStepLeft, firstStepVerticalMiddle)];
    }
  }

  // create vector line
  var lineShape = [[MSShapeGroup alloc] init];
  [lineShape setBezierPath: lineBezierPath];
  [lineShape setName:[firstStep name] + " -> " + [secondStep name]];

  // add border
  var lineShapeStyle = [lineShape style];
  var borders = [lineShapeStyle borders];
  if([borders count] <= 0) [borders addNewStylePart];

  // set border style
  var border = [lineShapeStyle border];
  border.setColor(MSColor.colorWithSVGString(connectorColor));
  border.thickness = 2;


  // add line shape to connectionsGroup
  [connectionsGroup addLayers:[lineShape]];

  // deselect steps
  [firstStep setIsSelected:false];
  [secondStep setIsSelected:false];
}

function sortByPosition(a,b)
{
  var sortOrder;

  if ([[a frame] maxY] < [[b frame] minY] || [[b frame] maxY] < [[a frame] minY]) {
    // sort from top to bottom
    sortOrder = [[a frame] top] - [[b frame] top];
  } else {
    // sort from left to right
    sortOrder = [[a frame] left] - [[b frame] left];
  }

  return sortOrder;
}

function getConnectionsGroup(parentGroup)
{
  var connectionsGroup = [parentGroup layerWithId:"AEConnections"];

  // create group if not exists
  if (connectionsGroup === null) {
    connectionsGroup = [parentGroup addLayerOfType:"group"];
    [connectionsGroup setName:"AEConnections"];
    [connectionsGroup setIsLocked:true];
  }

  return connectionsGroup;
}
